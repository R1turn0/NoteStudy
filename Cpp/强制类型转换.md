# 强制类型转换

[TOC]

## reinterpret_cast

`reinterpret_cast`是一种 C++ 转换运算符，允许程序员在不更改原始对象的情况下将指针或引用转换为不同的类型。 它是一个非常强大且具有潜在危险的运算符，应谨慎使用。

`reinterpret_cast`运算符可用于在指针和不相关类型的引用之间进行转换，或将数据对象的位重新解释为不同的类型。 这是一个例子：

```cpp
int i = 42;
float* fp = reinterpret_cast<float*>(&i);
```


在此示例中，我们有一个值为 42 的整数"i"。然后我们使用`reinterpret_cast`创建一个指向浮点数"fp"的指针，它获取"i"的地址并将其视为指向“浮点数”的指针。 这意味着"fp"现在指向与i相同的内存位置，但将"i"的位视为"float"

在此示例中，我们有一个值为 42 的整数“i”。然后我们使用“reinterpret_cast”创建一个指向浮点数“fp”的指针，它获取“i”的地址并将其视为指向“浮点数”的指针。 这意味着 fp现在指向与i相同的内存位置，但将i的位视为float`。

请注意，`reinterpret_cast`不执行任何类型检查或转换。 它只是将对象的位重新解释为不同的类型。 这意味着错误地使用`reinterpret_cast`会导致未定义的行为，例如读取或写入无效的内存位置。

因此，`reinterpret_cast`只应在绝对必要时使用，并且要透彻了解所涉及的类型和潜在风险。

## const_cast

`const_cast`是一种 C++ 转换运算符，允许程序员删除或添加变量或对象的常量。当程序员想要修改声明为 const 的变量或对象，或将 const 添加到非 const 变量或对象时使用

```cpp
void print(int* ptr) {
    std::cout << *ptr << std::endl;
}

int main() {
    const int i = 42;
    const int* ptr = &i;
    int* ptr2 = const_cast<int*>(ptr);
    *ptr2 = 7;
    print(const_cast<int*>(ptr));
    return 0;
}
```

在这个示例中有一个值为42的整形 i 和一个指向i的指针 ptr。我们使用`const_cast`创建一个非常量指针 ptr2 指向与 ptr 相同的内存位置。然后我们通过将 ptr2 设置为 7 来修改 i 的值。

`print`函数接受一个指向整数的非常量指针并打印它的值。我们再次使用`const_cast`将 ptr（常量指针）传递给 print。

 使用`const_cast`修改 const 对象可能很危险，应谨慎操作。修改 const 对象可能会导致未定义的行为和意外结果，因此只有在必要时才应该这样做。 

## static_cast

`static_cast`是一种 C++ 转换运算符，允许程序员执行已知在编译时安全的类型转换。它可用于相关类型之间的转换，例如将派生类指针转换为基类指针，或执行算术转换，例如将整数转换为浮点数。

```cpp
int main() {
    int i = 42;
    float f = static_cast<float>(i);
    std::cout << f << std::endl;

    Base* base = new Derived();
    Derived* derived = static_cast<Derived*>(base);
    derived->doSomething();

    return 0;
}
```

