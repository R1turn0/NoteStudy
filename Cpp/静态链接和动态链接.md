# 静态链接与动态链接

## 零、前前言

 Go和C/C++都为静态编译语言为什么Go不能使用许可壳，而C/C++可以使用？

主要为**静态链接的可执行程序**和**动态链接的可执行程序**：

1. Go语言编译时默认为静态链接的可执行程序，编译时会将系统库一起编译到程序内部，当可执行程序移动到其他的系统时，可以不依赖系统库而直接运行
2. GCC编译时默认为动态链接的可执行程序，编译时不会讲系统库一起编译，因此会依赖于系统中的库文件，当移动后的系统没有依赖库时程序无法运行

*测试*：GCC如果是使用`-static`的选项编译程序加壳的话就会和GoLang的程序一样报段错误，GCC编译是默认使用动态链接生成可执行程序，Go默认是使用静态链接生成可执行程序，所以加上`--linkshared`之后可以让Go语言使用动态链接的方式生成 

## 一、前言

一段代码从文本编辑器上产生到最终能够在机器上运行，经历了非常多的阶段，概括而言，至少包含了以下几个阶段：

1. **编译**: 编译器通过词法分析，语法分析，语义分析等，将一段代码翻译成汇编语言
2. **汇编**：将汇编语言翻译成机器指令
3. **链接**：解决符号之间的重定位问题
4. **装载**：将可执行文件加载到内存

## 二、编译

编译完成的是从源文件到二进制文件的转换过程

编译分为三步：

1. 对源文件进行预处理：处理一些 # 号定义的命令或语句（如宏、#include、预编译指令 #ifdef等），生成\*.i文件

2. 编译：词法分析、语法分析和语义分析等，生成*.s的汇编文件；

3. 汇编：将对应的汇编指令翻译成机器指令，生成可重定位的二进制目标文件

以上就是编译的过程

编译结束之后，需要进行链接

## 三、链接
### 静态链接

静态链接就是在 装载之前，就完成所有的符号引用的一种链接方式

在生成可执行文件的时候（链接阶段），把所有需要的函数的二进制代码都包含到可执行文件中去。因此，链接器需要知道参与链接的目标文件需要哪些函数，同时也要知道每个目标文件都能提供什么函数，这样链接器才能知道是不是每个目标文件所需要的函数都能正确地链接。如果某个目标文件需要的函数在参与链接的目标文件中找不到的话，链接器就报错了。目标文件中有两个重要的接口来提供这些信息：一个是符号表，另外一个是重定位表

静态链接的处理过程分为2个步骤：

1. **空间与地址的分配**。扫描所有的目标文件，合并相似段，收集当中所有的符号信息

2. **符号解析与重定位**。调整代码位置

优缺点：

1. 优点：在程序发布的时候就不需要依赖库，也就是不再需要带着库一块发布，程序可以独立执行
   1. 代码装载速度快，执行速度略比动态链接库快
   2. 只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，可避免DLL地狱等问题
2. 缺点：
   1. 浪费内存空间。在多进程的操作系统下，同一时间，内存中可能存在多个相同的公共库函数

   2. 程序的开发与发布流程受模块制约。 只要有一个模块更新，那么就需要重新编译打包整个代码。
       为了解决以上2个问题，就诞生了动态链接

### 动态链接

基本思想就是将对符号的重定位推迟到程序运行时才进行

只要推迟到运行时进行符号的重定位，就能解决静态链接的两个缺点

1. 在运行时重定位，如果在运行过程中调用了公共库函数或者其他模块的函数，系统只需要在内存中维护一份公共库代码即可，只要将不同应用程序对公共库函数的调用地址设置成相同即可
2. 理论上只要将需要替换的模块更新，无需将整个应用程序打包

#### 动态链接的实现

对于静态链接来说，系统只需要加载一个文件（可执行文件）到内存即可，但是在动态链接下，系统需要映射一个主程序和多个动态链接模块，因此，相比于静态链接，动态链接使得内存的空间分布更加复杂

不同模块在内存中的装载位置一定要保证不一样

##### 1. 装载时重定位

对于每一个模块，对于代码中符号的绝对引用，都需要加上一个基地址偏移量。（比如一个模块中存在一个绝对地址的引用A，它假定的是模块可以被加载到0x1000的地方，但是系统在加载该位置已经被其他模块占用了，系统选择将它加载到0x4000的地方，那么对绝对地址A的引用就需要被修改为A+0x3000，即修改代码）

但是它也有缺点，因为不同进程可能使用同一个模块，但是对于不同进程，代码段是不能共享的，因此，多个进程还是没有办法共享一个模块。因为不能修改模块当中的代码，一旦一个进程将共享模块的绝对地址修改了，其他进程此时调用就一定会报错

解决这个问题也有办法，在Windows中使用的就是装载时重定位，但是在Linux下使用的是另外一种方式

##### 2. 地址无关代码

一个模块的代码部分是共享的，但是数据部分是每个进程一个副本的。因此，地址无关代码的基本思想就是将代码段中的绝对地址引用剥离出来放到数据段中，以保证代码指令不变。在Android系统下进行SO文件的编译，默认就是产生地址无关代码

因此程序执行的流程就变成了：当模块A调用模块B的某个方法的时候，会从模块A的数据段部分找到模块B中函数地址，然后进行函数调用

#### 动态链接的优点与缺点

优点： 

1. 更加节省内存并减少页面交换
2. DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性

3. 不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数

4. 适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试

缺点：

1. 结构复杂
2. 引入了安全问题，这也是我们能够进行PLT HOOK的基础

## 三、库
上述多次提到库(lib)这个概念，所谓库就是一些功能代码经过编译连接后的可执行形式

库也有静态lib和动态lib之分：

1. 静态lib将导出声明和实现都放在lib中。编译后所有代码都嵌入到宿主程序
2. 动态lib相当于一个h文件，是对实现部分（.dll文件）的导出部分的声明。编译后只是将导出声明部分编译到宿主程序中，运行时候需要相应的dll文件支持



