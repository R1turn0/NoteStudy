# 静态链接与动态链接

[TOC]

## 一、前言

Go和C/C++都为静态编译语言为什么Go不能使用许可壳，而C/C++可以使用？

主要为**静态链接的可执行程序**和**动态链接的可执行程序**：

1. Go语言编译时默认为静态链接的可执行程序，编译时会将系统库一起编译到程序内部，当可执行程序移动到其他的系统时，可以不依赖系统库而直接运行
2. GCC编译时默认为动态链接的可执行程序，编译时不会讲系统库一起编译，因此会依赖于系统中的库文件，当移动后的系统没有依赖库时程序无法运行

测试：GCC如果是使用`-static`的选项编译程序加壳的话就会和GoLang的程序一样报段错误，GCC编译是默认使用动态链接生成可执行程序，Go默认是使用静态链接生成可执行程序，所以加上`--linkshared`之后可以让Go语言使用动态链接的方式生成 

## 二、编译

一段代码从文本编辑器上产生到最终能够在机器上运行，经历了编译是从源文件到二进制文件的转换过程：

1. **编译**: 编译器通过词法分析，语法分析，语义分析等，将一段代码翻译成汇编语言
2. **汇编**：将汇编语言翻译成机器指令，生成可重定位的二进制目标文件
3. **链接**：解决符号之间的重定位问题
4. **装载**：将可执行文件加载到内存

## 三、链接
### 1. 静态链接

静态链接就是在 装载之前，就完成所有的符号引用的一种链接方式

在生成可执行文件的时候（链接阶段），把所有需要的函数的二进制代码都包含到可执行文件中去。因此，链接器需要知道参与链接的目标文件需要哪些函数，同时也要知道每个目标文件都能提供什么函数，这样链接器才能知道是不是每个目标文件所需要的函数都能正确地链接。如果某个目标文件需要的函数在参与链接的目标文件中找不到的话，链接器就报错了。目标文件中有两个重要的接口来提供这些信息：一个是符号表，另外一个是重定位表

静态链接的处理过程分为2个步骤：

1. **空间与地址的分配**。扫描所有的目标文件，合并相似段，收集当中所有的符号信息

2. **符号解析与重定位**。调整代码位置

#### 静态链接的优点与缺点：

1. 优点：在程序发布的时候就不需要依赖库，也就是不再需要带着库一块发布，程序可以独立执行
   1. 代码装载速度快，执行速度略比动态链接库快
   2. 只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，可避免DLL地狱等问题
2. 缺点：
   1. 浪费内存空间。在多进程的操作系统下，同一时间，内存中可能存在多个相同的公共库函数

   2. 程序的开发与发布流程受模块制约。 只要有一个模块更新，那么就需要重新编译打包整个代码。
       为了解决以上2个问题，就诞生了动态链接

### 2. 动态链接

基本思想就是将对符号的重定位推迟到程序运行时才进行

只要推迟到运行时进行符号的重定位，就能解决静态链接的两个缺点

1. 在运行时重定位，如果在运行过程中调用了公共库函数或者其他模块的函数，系统只需要在内存中维护一份公共库代码即可，只要将不同应用程序对公共库函数的调用地址设置成相同即可
2. 理论上只要将需要替换的模块更新，无需将整个应用程序打包

#### a) 动态链接的实现

对于静态链接来说，系统只需要加载一个文件（可执行文件）到内存即可，但是在动态链接下，系统需要映射一个主程序和多个动态链接模块，因此，相比于静态链接，动态链接使得内存的空间分布更加复杂

不同模块在内存中的装载位置一定要保证不一样

**i. 装载时重定位**

对于每一个模块，对于代码中符号的绝对引用，都需要加上一个基地址偏移量。（比如一个模块中存在一个绝对地址的引用A，它假定的是模块可以被加载到0x1000的地方，但是系统在加载该位置已经被其他模块占用了，系统选择将它加载到0x4000的地方，那么对绝对地址A的引用就需要被修改为A+0x3000，即修改代码）

但是它也有缺点，因为不同进程可能使用同一个模块，但是对于不同进程，代码段是不能共享的，因此，多个进程还是没有办法共享一个模块。因为不能修改模块当中的代码，一旦一个进程将共享模块的绝对地址修改了，其他进程此时调用就一定会报错

解决这个问题也有办法，在Windows中使用的就是装载时重定位，但是在Linux下使用的是另外一种方式

**ii. 地址无关代码**

一个模块的代码部分是共享的，但是数据部分是每个进程一个副本的。因此，地址无关代码的基本思想就是将代码段中的绝对地址引用剥离出来放到数据段中，以保证代码指令不变。在Android系统下进行SO文件的编译，默认就是产生地址无关代码

因此程序执行的流程就变成了：当模块A调用模块B的某个方法的时候，会从模块A的数据段部分找到模块B中函数地址，然后进行函数调用

#### b) 动态链接的优点与缺点

优点： 

1. 更加节省内存并减少页面交换
2. DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性

3. 不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数

4. 适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试

缺点：

1. 结构复杂
2. 引入了安全问题，这也是我们能够进行PLT HOOK的基础

## 四、Windows Visual Studio 下的静态链接与动态链接

在 Visual Studio 中，`MT`、`MD`、`MTd` 和 `MDd` 是编译器选项，用于指定你的 C++ 项目在链接时如何处理 C++ 运行时库（CRT）。这些选项的区别主要在于运行时库的链接方式（静态或动态）以及是否包含调试信息。下面是每个选项的具体含义：

### 1. `MT` (Multithreaded)

- **静态链接多线程运行时库**：将多线程的 C++ 运行时库静态链接到你的可执行文件中。这意味着运行时库的代码会被包含在你的最终可执行文件中，生成的文件不会依赖于外部的 DLL 文件。
- **适用场景**：用于发布版本，不依赖外部 DLL，所有的 CRT 代码都被包含在可执行文件中，适合在没有 CRT DLL 的环境中运行。

### 2. `MD` (Multithreaded DLL)

- **动态链接多线程运行时库**：多线程的 C++ 运行时库通过动态链接（DLL）的方式使用。你的可执行文件将依赖于系统中的 `msvcrt.dll`（Microsoft C Runtime Library DLL）。
- **适用场景**：用于发布版本，适合需要减少最终可执行文件大小的场景，依赖于系统中提供的 CRT DLL。

### 3. `MTd` (Multithreaded Debug)

- **静态链接多线程调试运行时库**：与 `MT` 类似，但用于调试版本。该选项会链接调试版本的运行时库，包含额外的调试信息和一些调试功能（如堆检查）。
- **适用场景**：用于调试版本，便于开发者进行调试，但最终生成的可执行文件会更大。

### 4. `MDd` (Multithreaded Debug DLL)

- **动态链接多线程调试运行时库**：与 `MD` 类似，但用于调试版本。链接调试版本的运行时库，并依赖于调试版本的 `msvcrtd.dll`（调试版的 Microsoft C Runtime Library DLL）。
- **适用场景**：用于调试版本，适合开发过程中使用，最终可执行文件依赖于系统中提供的调试版 CRT DLL。

### 选择合适的选项：

- **发布版本**：通常选择 `MT` 或 `MD`。如果你希望可执行文件独立且不依赖外部 DLL，选择 `MT`。如果你希望减小可执行文件的大小并利用系统中的共享运行时库，选择 `MD`。
- **调试版本**：通常选择 `MTd` 或 `MDd`。如果你需要调试信息且希望独立的可执行文件，选择 `MTd`。如果你希望减少调试版本的可执行文件大小，并且系统中有相应的调试 DLL，可以选择 `MDd`。

在开发中，你可以在调试时使用 `MDd` 或 `MTd`，而在发布时使用 `MD` 或 `MT`。
