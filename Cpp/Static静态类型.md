# `Static` 静态类型

## 一、概述

1. 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。
2. 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。
3. 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。
4. 无论是在函数内部还是类中，`static` 变量的生命周期都与程序的生命周期一致，作用域则限定在声明它的区域内。
5. **C++11 的增强特性**：虽然 `static` 本身的语法在 C++11 中没有明显变化，但 C++11 引入了诸如 `constexpr`、智能指针等新特性，可以替代某些静态变量的应用场景，比如常量表达式的静态初始化等。

## 二、`static` 关键字的作用 

### 1. 静态局部变量（Static Local Variables）

- `static` 修饰局部变量时，使得被修饰的变量成为静态变量，存储在静态区。存储在静态区的数据生命周期与程序相同，在main函数之前初始化，在程序退出时销毁
- 而普通局部变量存储于进程栈空间,生命周期与函数生命周期相同，函数使用完毕会立即释放
- 在函数内部声明的静态局部变量仅在第一次调用时初始化，并且在整个程序生命周期中保留其值。
- 这使得每次调用函数时，该变量的值不会被重置。

示例：

```c++
#include <stdio.h>

void fn(void) {
    int n = 10;

    printf("n=%d\n", n);
    n++;
    printf("n++=%d\n", n);
}

void fn_static(void) {
    static int n = 10;

    printf("static n=%d\n", n);
    n++;
    printf("n++=%d\n", n);
}

int main(void) {
    fn();
    printf("--------------------\n");
    fn_static();
    printf("--------------------\n");
    fn();
    printf("--------------------\n");
    fn_static();

    return 0;
}
```

运行结果

```shell
-> % ./a.out 
n=10
n++=11
--------------------
static n=10
n++=11
--------------------
n=10
n++=11
--------------------
static n=11
n++=12
```

### 2. 修饰全局变量

全局变量本来就存储在静态区，因此 `static` 并不能改变其存储位置。但是 ` static `限制了其链接属性。被 `static` 修饰的全局变量只能被该包含该定义的文件访问（即改变了作用域）

### 3. 修饰函数

`static` 修饰函数使得函数只能在包含该函数定义的文件中被调用。对于静态函数，声明和定义需要放在同一个文件夹中。

### 4. 静态类成员（Static Class Members）

- 用 `static` 修饰类的数据成员使其成为**类的全局变量**，会被类的所有对象共享，包括派生类的对象，所有的对象都只维持同一个实例。 
- 因此，`static` 成员（静态成员变量）必须在类定义体外进行定义和初始化（初始化格式：int base::var=10;），而不能在构造函数内进行初始化，不过也可以用 `const` 修饰 `static` 数据成员在类内初始化。

```cpp
class MyClass {
public:
    static int count;
};

int MyClass::count = 0;  // 初始化静态成员变量
```

- 静态成员函数只能访问静态成员变量，因为它们不依赖于具体对象。

```cpp
class MyClass {
public:
    static int count;
    static void displayCount() {
        std::cout << "Count: " << count << std::endl;
    }
};
```

### 5. 静态成员函数（Static Member Functions）

- 静态成员函数不属于任何对象，可以在不创建对象的情况下直接调用。例如可以封装某些算法，比如数学函数，如 ln、sin、tan等等，这些函数本就没必要属于任何一个对象，所以从类上调用感觉更好，比如定义一个数学函数类 Math，调用 Math::sin(3.14); 还可以实现某些特殊的设计模式：如Singleton；
- 用 `static` 修饰成员函数只能访问类的静态成员，而不能访问非静态成员。这个类只存在这一份函数，所有对象共享该函数，不含 `this` 指针，因而只能访问类的static成员变量。

```cpp
MyClass::displayCount();
```

### 6. 最重要的特性：隐藏

当同时编译多个文件时，所有未加 `static` 前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏。

***不可以同时用 `const` 和 `static` 修饰成员函数。***

C++ 编译器在实现 `const` 的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数 `const this*`。但当一个成员为 `static` 的时候，该函数是没有 `this` 指针的。也就是说此时 `const` 的用法和 `static` 是冲突的。我们也可以这样理解：两者的语意是矛盾的。`static` 的作用是表示该函数只作用在类型的静态变量上，与类的实例没有关系；而 `const` 的作用是确保函数不能修改类的实例的状态，与类型的静态变量没有关系。因此不能同时用它们。

